{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido al Blog de Daniel Maga\u00f1a P\u00e9rez","text":"<p>Aqu\u00ed aprender\u00e1s muchas cosas relacionadas con el ciclo de asir concretamente con la asignatura de iaw.</p>"},{"location":"#_1","title":"Principal","text":"<p>wordpress</p>"},{"location":"14_1-wordpress-docker-compose/","title":"Practica 14.1 Instalaci\u00f3n de WordPress usando contenedores Docker y Docker Compose","text":""},{"location":"14_1-wordpress-docker-compose/#para-la-creacion-de-la-instancia","title":"Para la creaci\u00f3n de la Instancia","text":"<p>Voy a usar terraform debido a su sencillez y que requiere de menor tiempo a la hora de generar grupos de seguridad , instancia y dem\u00e1s.</p> <p>Importante voy a tener los puertos :</p> <ul> <li>80 y el 443 lo utilizar\u00e1 la imagen de https-portal.</li> <li>8080 Es el puerto que utilizaremos para el phpmyadmin y as\u00ed conectarnos.</li> <li>22 Nos conectaremos por ssh.</li> </ul> <p>Para ejecutar el archivo tendremos que escribir:</p> <pre><code>terraform init\n</code></pre> <p>EL comando mencionado nos instalar\u00e1 los m\u00f3dulos necesarios para ejecutar el archivo.</p> <p>EL siguiente comandonos permitir\u00e1 lo que es el archivo (recordar, que para ejecutar este comando como el anterior hay que estar dentro del directorio):</p> <pre><code>terraform apply\n</code></pre> <p>Contenido del archivo es el siguiente:</p> <pre><code>#Configuramos el proveedor de AWS y le ponemos la regi\u00f3n.\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n#---------------------------------------------------------------------------------------------------------------------------------\n#Creamos la maquina junto con sus recursos\n#-------------------------------------------------------------------------------------------------------------------------------------------\n\n# Creamos un grupo de seguridad, especificando las condiciones que tendr\u00e1.\n#No hay que preocuparse por nivelarlas la informaci\u00f3n por el comando terraform fmt.\n#En aws_security_group (este parametro es un recurso, por lo tanto debe de ser la misma) le decimos que va a ser un grupo de seguridad.\n\nresource \"aws_security_group\" \"sg_practica14_1\" {\n  name        = \"sg_practica14_1\"\n  description = \"Grupo de seguridad para la instancia de sg_practica14_1\"\n\n  #Especificamos los puertos y su condiciones\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  ingress {\n    from_port   = 8080\n    to_port     = 8080\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n#Las siguientes lineas son para las reglas de salida (son importante ya que de lo contrario no podr\u00eda por ejemplo actualizar repositorios)\n  egress {\n    from_port = 0\n    to_port = 0\n    protocol = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\n# Creamos la instancia\n#La primera l\u00ednea es para declarar lo que vamos a hacer.\n#Despu\u00e9s le pasamos los elementos ensenciales como la ami, \n#su capacidad, la clave shh y as\u00edganamos la instancia al grupo.\n\n\nresource \"aws_instance\" \"practica14_1\" {\n  ami             = \"ami-00874d747dde814fa\"\n  instance_type   = \"t2.large\"\n  key_name        = \"vockey\"\n\n#En security_groups especificamos el grupo de seguridad.\n\n  security_groups = [aws_security_group.sg_practica14_1.name]\n\n  #En la siguiente l\u00ednea ponemos el nombre a la instancia.\n  tags = {\n    Name = \"practica14_1\"\n  }\n}\n\n# Creamos una IP el\u00e1stica. En este apartado hago referencia \n#al nombre de la instancia. \n\nresource \"aws_eip\" \"ip_elastica\" {\n  instance = aws_instance.practica14_1.id\n}\n\n# Mostramos la IP p\u00fablica de la instancia\noutput \"elastic_ip\" {\n  value = aws_eip.ip_elastica.public_ip\n}\n</code></pre>"},{"location":"14_1-wordpress-docker-compose/#apartado-de-las-imagenes-docker","title":"Apartado de las im\u00e1genes Docker","text":"<p>Para ello voy a utilizar un archivo llamado docker-compose.yml y tendr\u00e1 un archivo .env (que tendr\u00e1 el contenido de las variables).</p> <pre><code># WordPress variables\n\n#Nombre de la base de datos.\nWORDPRESS_DB_NAME=wp_database\n\n#Nombre del usuario\nWORDPRESS_DB_USER=wp_user\n\n#NOmbre de la contrase\u00f1a\nWORDPRESS_DB_PASSWORD=wp_password\n\n# MySQL Server environment variables\nMYSQL_ROOT_PASSWORD=root\n</code></pre> <p>El contenido del archivo docker-compose.yml:</p> <pre><code>\nversion: '3'\n\n#En services declaramos las im\u00e1genes y dem\u00e1s.\n\nservices:\n\n#Instalaci\u00f3n de la im\u00e1gen de wordpress esta im\u00e1gen est\u00e1 sacada de docker hub, si yo en image pongo wordpress por defecto me coger\u00e1 la version latest. (Me coger\u00e1 siempre la \u00faltima el problema de esto que puede salir una versi\u00f3n que no sea compatible, por eso pongo una versi\u00f3n concreta)\n\n  wordpress:\n    image: wordpress:6.1\n    #En ports pongo los puertos , en esta imagen como m\u00e1s adelante voy a usar https por eso no asignar\u00e9 los puerto a wordpress ya que podr\u00eda dar problemas.\n#    ports:\n#      - 80:80\n    environment:\n    #En las siguientes lineas usaremos las variables : (importante, para declarar las variables hay que leer las instrucciones de como funcionan dichas variables.)\n\n    #Ponemos el nombre del servicio de mysql.\n    #Asignamos el nombre a la base de datos\n    #Asignamos el nombre del usuario para la base de datos.\n    #Asignamos contrase\u00f1a a dicho usuario\n      - WORDPRESS_DB_HOST=mysql\n      - WORDPRESS_DB_NAME=${WORDPRESS_DB_NAME}\n      - WORDPRESS_DB_USER=${WORDPRESS_DB_USER}\n      - WORDPRESS_DB_PASSWORD=${WORDPRESS_DB_PASSWORD}\n    volumes: \n    #Montamos el volumen, esta direcci\u00f3n hay que consultarlo en docker hub (wordpress), debido a que no puedo poner la ruta que yo quiera sino la que me diga en las instrucciones, de lo contrario no funcionar\u00e1.\n    #Si pongo wordpress_data no compartir\u00e1 nada de mi ordenador a la imagen, si yo quisiera que usar\u00e1 archivos locales pondr\u00eda ./ruta_del_archivo.\n      - wordpress_data:/var/www/html\n    depends_on:\n    #Para indicarle que se inicie cuando la imagen de mysql, se inicie y adem\u00e1s cuando mysql funcione bien\n      mysql:\n        condition: service_healthy\n    #En caso de error que reinicie siempre.\n    restart: always\n    #Declaramos las redes a las que pertenece (wordpress necesita estar en las dos debido a que necesitar\u00e1 tener acceso a mysql (backend-network) y al exterior para ofrecer contenido al exterior(frontend-network))\n    networks: \n      - frontend-network\n      - backend-network\n\n#Para la imagen de mysql.\n\n#En imagen ponemos la versi\u00f3n que queremos descargar en mi caso es mysql:8.0\n\n  mysql:\n    image: mysql:8.0\n    ports:\n    #Ponemos el puerto que usar\u00e1, el puerto 3306 lo voy a comentar por seguridad, ya que no quiero que cualquiera pueda acceder.\n#      - 3306:3306\n    environment:\n\n    #Usamos las variables para:\n\n    #Usar contrase\u00f1a de root.\n    #Asignamos el nombre a la base de datos\n    #Asignamos el nombre del usuario para la base de datos.\n    #Asignamos contrase\u00f1a a dicho usuario\n\n      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\n      - MYSQL_DATABASE=${WORDPRESS_DB_NAME}\n      - MYSQL_USER=${WORDPRESS_DB_USER}\n      - MYSQL_PASSWORD=${WORDPRESS_DB_PASSWORD}\n    volumes:\n    #Generamos el volumen, y nos fijamos que la ruta que hemos puesto es la que viene en las instrucciones.\n      - mysql_data:/var/lib/mysql\n    #En caso de que haya alg\u00fan error se reiniciar\u00e1 siempre.  \n    restart: always\n    #Importante:\n    # El healthcheck, sirve para garantizar que el servicio de MySQL est\u00e1 listo para aceptar conexiones, si yo pusiera depends (y el servicio) significar\u00eda como ese este iniciado, healthcheck no es cuando se haya iniciado sino que se produce hasta que al fin se haya comprobado que los parametros hayan transcurrido con exito.\n\n    #En este caso me comrpueba el usuario y la contrase\u00f1a\n    healthcheck:\n      test: mysql --user=${WORDPRESS_DB_USER} --password=${WORDPRESS_DB_PASSWORD} -e \"SHOW DATABASES;\"\n    #interval: Especifica la frecuencia con la que se ejecutar\u00e1 el healthcheck. En este caso, se est\u00e1 especificando un intervalo de 6 segundos.\n\n    #timeout: Especifica el tiempo m\u00e1ximo que se permitir\u00e1 para que el healthcheck complete. En este caso, se est\u00e1 especificando un timeout de 3 segundos.\n\n    #retries: Especifica el n\u00famero de intentos que se realizar\u00e1n si el healthcheck falla. En este caso, se est\u00e1 especificando 5 intentos.\n      interval: 6s\n      timeout: 3s\n      retries: 5\n    networks: \n    #A\u00f1adimos la red\n      - backend-network\n\n#Ahora usaremos la imagen phpmyadmin la version 5.2\n  phpmyadmin:\n    image: phpmyadmin:5.2\n    ports:\n    #NOs conectaremos por el puerto 8080\n      - 8080:80\n    environment: \n      - PMA_HOST=mysql\n      #Ponemos que se inicie cuando funcione perfectamente mysql\n    depends_on:\n      mysql:\n        condition: service_healthy\n    #Reiniciamos siempre\n    restart: always\n    #Phpmyadmin debe de estar en las dos redes.\n    networks: \n      - frontend-network\n      - backend-network\n\n#Usaremos la imagen https-portal version 1, importante aclarar que no es oficial, esta imagen est\u00e1 desarrollada por steveltn\n\n  https-portal:\n    image: steveltn/https-portal:1\n    ports:\n    #Los puertos que trabajar\u00e1 son los siguientes:\n      - 80:80\n      - 443:443\n\n    #Montamos el volume en /var/lib/https-portal\n    volumes:\n      - ssl_certs_data:/var/lib/https-portal\n    environment:\n    #He puesto dos tipos de dominios, no pueden ser dos a la vez, la primera se usar\u00e1 de forma local y la otra es para acceder a internet, el dominio que pongo tiene que estar registrado en no-ip.\n    # http://wordpress:80 es wordpress debido al nombre del servicio, si tuviese otro nombre cambiariamos wordpress por el nombre del servicio que actue por wordpress\n\n#      DOMAINS: 'localhost -&gt; http://wordpress:80 #local'\n      DOMAINS: 'dmp-test.ddns.net -&gt; http://wordpress:80 #production'\n    depends_on:\n    #Ponemos que este servicio se monte cuando wordpress haya iniciado\n      - wordpress\n    #Reiniciamos siempre\n    restart: always\n    #Estar\u00e1 en la red frontend-network , no necesita estar en backend-network, ya que esta wordpress.\n    networks:\n      - frontend-network\n\n#Tenemos que volver a declarar la ruta de los volumenes.\n\nvolumes:\n  mysql_data:\n  wordpress_data:\n  ssl_certs_data:\n\n#Tenemos que volver a declarar el nombre de las redes.\n\nnetworks:\n  frontend-network:\n  backend-network:\n</code></pre> <p>Ya tendremos creada la instancia y el archivo docker-compose.yml con las imagenes.</p> <p>Faltar\u00eda ejecutar el archivo docker-compose.yml y sus herramintas:</p>"},{"location":"14_1-wordpress-docker-compose/#ejecutar-los-servicios-e-instalar-las-herramientas-necesarias-para-el-proceso","title":"Ejecutar los servicios e instalar las herramientas necesarias para el proceso","text":"<pre><code>---\n- name: Playbook para instalar preparar los servicios de la maquina docker\n  hosts: maquina\n  become: yes\n\n  tasks:\n\n    - name: Actualizar los repositorios\n      apt:\n        update_cache: yes\n\n    - name: Instalar el docker.io\n      apt:\n        name: docker.io\n        state: present\n\n    - name: Instalamos pip\n      apt:\n        name: python3-pip\n        state: present\n\n    - name: Instalar el docker\n      pip:\n        name: docker\n        state: present\n\n    - name: Instalar el docker-compose\n      pip:\n        name: docker-compose\n        state: present\n\n\n    - name: Creamos el directorio\n      file:\n        path: /home/ubuntu/.docker/cli-plugins\n        state: directory\n        mode: 0775\n        owner: ubuntu\n        group: ubuntu\n\n    - name: Descargar docker compose\n      get_url:\n        url: https://github.com/docker/compose/releases/download/v2.15.1/docker-compose-linux-x86_64\n        dest: /home/ubuntu/.docker/cli-plugins/docker-compose\n        mode: 0775\n        owner: ubuntu\n        group: ubuntu\n\n    - name: A\u00f1adimos el usuario al grupo docker\n      user:\n        name: ubuntu\n        groups: docker\n        append: yes\n\n    - name: Permisos de socket docker\n      file:\n        path: /var/run/docker.sock\n        mode: 0777\n\n    - name: Reiniciamos docker\n      service:\n        name: docker\n        state: restarted\n\n    - name: Copiamos el archivo\n      copy:\n        src: ../../docker/\n        dest: /home/ubuntu/docker\n\n    - name: Ejecutar docker-compose\n      docker_compose:\n        project_src: /home/ubuntu/docker\n        files:\n          - docker-compose.yml\n        state: present\n        docker_host: unix://var/run/docker.sock\n</code></pre>"},{"location":"14_1-wordpress-docker-compose/#comprobacion","title":"Comprobaci\u00f3n","text":"<p>Si pongo el dominio en el navegador, aparecer\u00e1 wordpress (ya lo habia instalado):</p> <p></p> <p>Si pongo el dominio (poniendo http) y el puerto:8080 me llevar\u00e1 a phpmyadmin: </p>"},{"location":"6-prestasho-ansible/","title":"Pr\u00e1ctica 6 Prestashop mediante Ansible","text":"<p>Esta pr\u00e1ctica es muy parecido a la que hice en el repositorio 5, la \u00fanica diferencia es que vamos a utilizar una herramienta llamada Ansible , esta herramienta, nos permite configurar los equipos de una red sin que tengamos que hacerlo uno a uno , esto hace que la configuraci\u00f3n de las m\u00e1quinas sea mucho m\u00e1s optimo.</p> <p>Para ello vamos a utilizar archivos con la extensi\u00f3n yml (en estos archivos vamos a poner los comandos para llevar a cabo la administraci\u00f3n de los equipos de nuestra red.</p> <p>Cada vez que queramos ejecutar un archivo yml, deberemos de ejecutar el comando:</p> <p>ansible-playbook -i inventario install_lamp.yml</p> <p>Donde el archivo_lamp.yml es el que en mi caso he ejecutado, pero podr\u00eda ser cualquiera</p>"},{"location":"6-prestasho-ansible/#el-archivo-inventario","title":"El archivo inventario","text":"<p>Es importante ya que aqu\u00ed definimos los grupos a con los que vamos a trabajar Para ello habr\u00e1 que especificar mediante las IPs de los los grupos de los equipos. (este no tendr\u00e1 extensi\u00f3n)</p> <ul> <li>Donde pone ansible_user especificamos el usuario con el que accedemos a esos equipos.</li> <li>ansible_ssh_private_key es la clave privada</li> <li>ansible_ssh_common_args es para que no nos pregunte si aceptamos los terminos al principio</li> </ul> <p></p>"},{"location":"6-prestasho-ansible/#archivo-installl_lampyml","title":"Archivo installl_lamp.yml","text":"<p>Esto lo voy a explicar una vez ya que se repetir\u00e1 cada vez que creemos un archivo con extensi\u00f3n yml con la herramienta de Ansible.</p> <p></p> <p>Empezamos poniendo el --- , esto se utilizar para definir una lista. name funciona solo de forma informativa. Los host se utilizar para definir un grupo (que ya esta creada en el inventario).</p> <p>Become = yes, es para decir que entramos como root.</p> <p>La palabra vars es para decir que vamos a crear una variable , que tenga un lista que nosotros le pongamos, en este caso por ejemplo estaba diciendo que quiero los paquetes de php, m\u00e1s adelante declaro la variables php_paquetes y esos paquetes se deber\u00e1n de instalar , sin tener que poner paquete por paquete para la instalaci\u00f3n.</p> <p>En el tasks vamos a ejecutar las operaciones.</p> <ul> <li> <p>La primera operaci\u00f3n  (actualizar repositorios) , pongo el name para saber que operaci\u00f3n es. Despu\u00e9s pongo apt por ser la libreria que \u00fatiliza este comando, update_cache es para que realizar la operaci\u00f3n.</p> </li> <li> <p>La segunda operaci\u00f3n  (Instalar el servidor web de apache) pongo el name primero que es para explicar lo que har\u00e9, el apt es por la librer\u00eda y state es el estado en que me lo quiero instalar porque yo puedo instalarlo y que no este activo pues esas cosas se definen aqu\u00ed.</p> </li> <li> <p>Instalar PHP funciona tambi\u00e9n con apt, en name vamos llamar a la variable que hemos creado con anterioridad (as\u00ed los paquetes que hemos llamado antes, pues se descargar\u00e1n e instalar\u00e1n de golpe), el state: present* le decimos que los queremos activos</p> </li> <li> <p>Funcionalidades de phpmyadmin Es lo mismo que proceso que en el anterior.</p> </li> </ul> <p>Pasamos a la siguiente foto de este archivo:</p> <p></p> <ul> <li> <p>Para borrar un archivo debo de poner file para definir que es un archivo, path es la ubicaci\u00f3n entera del archivo. Con el state: absent.</p> </li> <li> <p>Para reiniciar un servicio pongo service en name (nombre del servio) y en state (lo que busque) en mi caso pongo restarted para reinicar.</p> </li> </ul>"},{"location":"6-prestasho-ansible/#el-archivo-install_cerbot","title":"El archivo install_cerbot","text":"<p>Aqu\u00ed vamos a configurar todo lo necesario para poner utilizar el protocolo https , en nuestra tienda de Prestashop de maner\u00e1 que nos comunicaremos con la tienda a trav\u00e9s del puerto 443.</p> <p></p> <p>Creo dos variables:</p> <ul> <li> <p>DOMAIN que es donde meter\u00e9 el dominio que he asociado la ip del cliente.</p> </li> <li> <p>PS_EMAIL es donde meter\u00e9 el correo que quiera asociar con el dominio</p> </li> </ul> <p>Despu\u00e9s ejecuto el siguiente contenido:</p> <ul> <li> <p>Lo primero de todo me asegura que cerbot , no est\u00e1 instalado en la m\u00e1quina.</p> </li> <li> <p>Lo siguiente es para instalar snap que es como la librer\u00eda de apt, pero con otras funcionalidades.</p> </li> <li> <p>Y por \u00faltimo Descargo el certificado con las variables que he mencionado, para ello utilizo el ansible.builtin.comand </p> </li> <li> <p>Finalmente Reiniciamos el servidor</p> </li> </ul>"},{"location":"6-prestasho-ansible/#archivo-installl_toolsyml","title":"Archivo installl_tools.yml","text":"<ul> <li> <p>La variable que pongo al principio viene dada por una operaci\u00f3n que explicar\u00e9 m\u00e1s adelante(b\u00e1sicamente cuando me descargue la herramienta que me dice las necesidades de prestashop me pedia esos m\u00f3dulos).</p> </li> <li> <p>Unzip Me permitira descomprimir archivos.</p> </li> <li> <p>Primer Borrado y segundo borrado es por si tengo la carpeta de prestashop en el directorio /var/www/html y deseo borrarlo para tener una instalaci\u00f3n limpia y el segundo hace referencia a la herramienta de verificaci\u00f3n de prestashop.</p> </li> <li> <p>Clonaci\u00f3n de la herramienta verificadora Utilizo el git porque esa librer\u00eda me permite clonar , repo es para poner la url y con  path pongo donde me gustar\u00eda tener los archivos.</p> </li> <li> <p>Modificaci\u00f3n de los permisos Aqu\u00ed pongo el directorio con path en state: directry digo que es un directorio. owner (pongo al usuario) y group (pongo al grupo) , porque el va a hacer referencia a usuarios de apache.</p> </li> </ul> <p>Seguimos con el archivo:</p> <p></p> <ul> <li> <p>Instalaci\u00f3n de la variables que he generado antes Una cosa que no he mencionado antes, es que las variables deben de estar dentro de {{Variable}} , as\u00ed es como deber\u00eda de estar.</p> </li> <li> <p>Instalci\u00f3n de los modulos necesarios pongo apache2module que me deja instalar los modulos necesarios de apache.</p> </li> <li> <p>Cambiar el contenido del archivo php.ini</p> </li> </ul> <p>Para ello pongo ansible.bulting.lineinfile</p> <p>Con Path le digo la ubicaci\u00f3n del archivo.</p> <p>Con search_string Me busca el contenido que quiero sustituir.</p> <p>Con line me permite poner la linea tal cual necesito, el problema de esto que me quita la linea completa, en la pr\u00f3xima pr\u00e1ctica utilizar\u00e9 replace.</p> <p>Seguimos en el mismo archivo:</p> <p></p> <ul> <li> <p>Descargar un archivo Esto equivale al comando wget, podria poner get_url y funcionar\u00eda. En la url pongo la direcci\u00f3n del archivo y en dest pongo el destino.</p> </li> <li> <p>Descomprimir un archivo Utilizamos unarchive que nos permitir\u00e1 hacer la funci\u00f3n mencionada. En src pongo la ubicaci\u00f3n actual y en dest el destino.</p> </li> <li> <p>Movemos los archivos de lugar y aprovechamos para cambiarle los permisos , adem\u00e1s ponemos recurse para que se haga de forma recursiva, es decir, para que lo haga en los subdirectorios.</p> </li> </ul> <p>Seguimos con el archivo:</p> <p></p> <ul> <li> <p>A\u00f1adimos los permisos de escritura necesario , adem\u00e1s de los permisos de apache y loa hacemos de forma recursiva</p> </li> <li> <p>Descagamos PhpMyadmin y la ubicamos donde queramos en mi caso /tmp</p> </li> <li> <p>Descargamos la herramienta unzip para extraer archivos</p> </li> <li> <p>Eliminar el archivo.zip de phpmyadmin no pasar\u00e1 nada porque ya hemos descomprimido la descarga.</p> </li> <li> <p>Desplazmos el phpmyadmin a /var/www/html , importante para mover el archivo de sitio debemos de ponerle remote_src: yes para que lo haga en el cliente, de lo contrario lo har\u00e1 solo en el equipo local.</p> </li> <li> <p>A\u00f1adimos los permisos de apache a PhpMyadmin y que sea de manera recursiva</p> </li> <li> <p>Reiniciamos el servidor apache</p> </li> </ul>"},{"location":"6-prestasho-ansible/#archivo-deployyml","title":"Archivo deploy.yml","text":"<p>En este archivo vamos a instalar y configurar Prestashop PhpMyAdmin</p> <p></p> <p>Declaramos dos grupos de variables.</p> <ul> <li> <p>Primer grupo de variables es para la base de datos execto DOMAIN y PS_DB_SSL</p> </li> <li> <p>El segundo grupo de variables es para los datos de usuario que vaya a entrar en la cuenta de la pr\u00e1gina web.</p> </li> </ul> <p>Nos vamos a los comandos</p> <ul> <li> <p>Python3-pip es una librer\u00eda como apt pero con otras funcionalidades, nos permitir\u00e1 descargar pymysql.</p> </li> <li> <p>pymsql Nos es un modulo que nos permite comunicar la base de datos con la tienda.</p> </li> <li> <p>Creaci\u00f3n de la base de datos usamos mysql_db para declara (acci\u00f3n) que vamos a crear una base de datos.En name ponemos la variable de la base de datos y login_unix_socket nos permite ejecutar el socket de mysql haciendola funcionar.</p> </li> <li> <p>Creaci\u00f3n del usuario en la base de datos nos obliga a poner no_log: true , utilizaremos mysql_user por la acci\u00f3n de crear un usuario en la base de datos, en name ponemos el nombre de la base de datos. En password ponemos la contrase\u00f1a de la base de datos, en priv a\u00f1adimos los permisos sobre la base de datos , diciendole que tenga permisos sobre esta misma base de datos y de todas las tablas.  </p> </li> </ul> <p>Seguimos con el mismo archivo</p> <p></p> <ul> <li> <p>Vamos a Instalar Prestashop con la opci\u00f3n de ansible.builtin.command nos permitir\u00e1 insertar informaci\u00f3n (variables) al archivo index_cli.php la opci\u00f3n de args le pasamos el directorio donde se encuentra el archivo mencionado.</p> </li> <li> <p>Despu\u00e9s de la instalaci\u00f3n nos obliga a borrar el archivo install por motivos de seguridad</p> </li> <li> <p>Movemos el archivo prestashop a /var/www/html</p> </li> <li> <p>A\u00f1adimos los permisos de prestashop poniendo como propietario tanto grupo y usuario www-data lo hacemos de forma recursiva.</p> </li> <li> <p>Reiniciamos el servidor Apache</p> </li> </ul>"},{"location":"6-prestasho-ansible/#archivo-conf_apacheyml","title":"Archivo conf_apache.yml","text":"<p>Cuando instal\u00e9 todo en el cliente descarg\u00e9 los archivos 000-default.conf y 000-default-le-ssl.conf los met\u00ed en un repositorio de github de maner\u00e1 que cuando quiera modificar algo solo tengo que modificarlo en github y hacer como un git clone borrando los iriginales y aplicanod las modificaciones</p> <p></p> <ul> <li> <p>Eliminamos los archivos 000-default.conf y 000-default-le-ssl.conf</p> </li> <li> <p>Hago la clonaci\u00f3n con los cambios efectuados</p> </li> <li> <p>Muevo los dos archivos al directorio /etc/apache2/sites-available/</p> </li> <li> <p>Reiniciamos el servidor de apache</p> </li> </ul> <p>Esto es lo que he a\u00f1adido en los dos archivos:</p> <p>La primera l\u00ednea es para que me coja por defecto el prestashop.</p> <p>La segunda l\u00ednea es para que me me permita navegar por la p\u00e1gina web </p> <p></p>"},{"location":"6-prestasho-ansible/#comprobacion-de-que-funciona","title":"Comprobaci\u00f3n de que funciona","text":""},{"location":"9-practica/","title":"Pr\u00e1ctica 9 INSTALACI\u00d3N DE WORDPRESS EN DISTINTOS NIVELES","text":"<ul> <li>Fase 0 </li> </ul> <p>Instalaremos el wordprees con solamente un nodo.</p> <ul> <li>Fase 1 </li> </ul> <p>En esta fase, usaremos dos m\u00e1quinas que tendr\u00e1n dos niveles distintos una es el front-end(que tendr\u00e1 wordpress y apache) y el back-end(que le servir\u00e1 la base de datos al front-end).</p> <ul> <li>Fase 2 </li> </ul> <p>La siguiente fase constar\u00e1 de 5 m\u00e1quinas:</p> <p>La primera capa, pondremos un balanceador que nos permitir\u00e1 comunicar con l\u00e1s m\u00e1quinas que hay en las capas inferiores) </p> <p>La segunda capa, tiene 3 niveles font-end (dos que servir\u00e1n como servidor apache, y un servidor nfs que contestar\u00e1 a las peticiones que les realice apache, es decir, est\u00e1 maquina tendr\u00e1 wordpress, entonces cada vez que alguien se quiera conectar al wordpress el servidor de apache preguntar\u00e1 al servidor nfs para que esa respuesta llegue finalmente al balanceador).</p> <p>La tercera capa es el back-end , la m\u00e1quina que est\u00e1 en este nivel nos dar\u00e1 la base de datos y con un usuario para wordpress.</p> <p>Importante la m\u00e1quina back-end tiene que tener el puerto 3306 y el servidor nfs el puerto 2049</p> <p></p>"},{"location":"9-practica/#fase-0","title":"FASE 0","text":"<p>Instalaremos todo lo necesario para tener en una \u00fanica m\u00e1quina wordpress.</p> <p>Nos vamos al archivo de las variables.</p> <pre><code>---\nDB_HOST_PRIVATE_IP: localhost\nDB_NAME: db_name\nDB_USER: db_user\nDB_PASS: db_pass\n\nWP_HOME: https://prac9dmpasir.ddns.net\nWP_SITEURL: https://prac9dmpasir.ddns.net/wordpress\n\nEMAIL: chema51226@gmail.com\nDOMAIN: prac9dmpasir.ddns.net\n\n\nphp_paquetes:\n  - php\n  - libapache2-mod-php \n  - php-mysql\n</code></pre> <p>La primera primera variables hay que poner la ip privada de la m\u00e1quina que tenga la base de datos (back-end).</p> <p>DB_NAME, DB_USER, DB_PASS son variables para la base de datos , donde diremos la base de datos, usuario y contrasse\u00f1a.</p> <p>WP_HOME es la url que utilizan los clientes. WP_SITEURL es la url que utilizar\u00e1n los administradores para configurar y dem\u00e1s wordpress.</p> <p>EMAIL (CORREO) y DOMAIN (DOMINIO) son las variables para obtener el certificado.</p> <p>La \u00faltima variable es php_paquetes tiene una lista de contenido para que nos descargue a la vez los paquetes.</p> <p>Nos vamos a la pila lamp.</p> <pre><code>---\n- name: Playbook para instalar la pila lamp\n  hosts: front\n  become: yes\n\n  tasks:\n\n  - name: A\u00f1adimos las variables\n    ansible.builtin.include_vars:\n      ./variables.yml\n\n  - name: Actualizar los repositorios\n    apt:\n      update_cache: yes\n\n  - name: Instalar el servidor web Apache\n    apt:\n      name: apache2\n      state: present\n\n  - name: Instalar el servidor mysql\n    apt:\n      name: mysql-server\n      state: present\n\n  - name: Instalar PHP \n    apt:\n      name: \"{{php_paquetes}}\"\n      state: present\n\n#-------------------------------------------------------------------\n\n  - name: Eliminamos los archivos clonados innecesarios.\n    file:\n      path: /etc/apache2/sites-available/000-default.conf\n\n\n  - name: Clonamos el repositorio\n    git:\n      repo: https://github.com/Daniel-Magana512/practica9V.git\n      dest: /tmp/archivos\n\n  - name: Movemos los archivos de configuraci\u00f3n a /etc/apache2/sites-availeble\n    copy:\n      src: /tmp/archivos/fase0/conf/000-default.conf\n      dest: /etc/apache2/sites-available/\n      remote_src: yes\n\n  - name: Movemos el dir.conf\n    copy:\n      src: /tmp/archivos/fase0/conf/dir.conf\n      dest: /etc/apache2/mods-available\n      remote_src: yes\n\n\n  - name: Eliminamos los archivos clonados innecesarios.\n    file:\n      path: /tmp/archivos\n\n#--------------------------------------------------------------\n\n  - name: Instalamos el m\u00f3dulo rewrite\n    apache2_module:\n        name: rewrite\n        state: present\n\n  - name: Reiniciamos el servidor apache\n    service:\n      name: apache2\n      state: restarted \n</code></pre> <p>A\u00f1adimos el archivo de las variables.</p> <p>Instalamos mysql-server, php, y apache.</p> <p>Clonamos este mismo repositorio, para a\u00f1adir el dir.conf y el 000-default.conf.</p> <p>Instalamos el m\u00f3dulo de apache rewrite para wordpress.</p> <p>Reiniciamos apache.</p> <p>Obtenemos el certificado</p> <pre><code>---\n- name: Playbook para instalar cerbot\n  hosts: front\n  become: yes\n\n  tasks:\n\n\n  - name: A\u00f1adimos las variables\n    ansible.builtin.include_vars:\n      ./variables.yml\n\n  - name: Instalaci\u00f3n de cerbot mediante snap\n    community.general.snap:\n      name: certbot\n      classic: true\n      state: present\n\n  - name: Descarga el certificado \n    ansible.builtin.command: certbot --apache -m {{EMAIL}}  --agree-tos --no-eff-email -d {{DOMAIN}}\n    register: my_output\n    changed_when: my_output.rc !=0\n\n  - name: Reinicamos apache2\n    service: \n      name: apache2\n      state: restarted\n</code></pre> <p>Creamos la base de datos e instalamos Wordpress</p> <pre><code>---\n- name: Playbook para instalar la pila wordpress\n  hosts: front\n  become: yes\n\n  tasks:\n\n  - name: A\u00f1adimos las variables\n    ansible.builtin.include_vars:\n      ./variables.yml\n\n  - name: Instalamos el gestor de paquetes de Python3\n    apt:\n      name: python3-pip\n      state: present\n\n  - name: Instalamos el modulo de pymysql\n    pip:\n      name: pymysql\n      state: present\n\n  - name: Crear una base de datos\n    mysql_db:\n      name: \"{{ DB_NAME }}\"\n      state: present\n      login_unix_socket: /var/run/mysqld/mysqld.sock\n\n  - name: Creamos un usuario para la Base de datos\n    no_log: true\n    mysql_user:\n      name: \"{{ DB_USER }}\"\n      host: '%'\n      password: \"{{ DB_PASS }}\"\n      priv: \"{{ DB_NAME }}.*:ALL,GRANT\"\n      state: present\n      login_unix_socket: /var/run/mysqld/mysqld.sock\n\n  - name: Reiniciamos el servidor mysql\n    service:\n      name: mysql\n      state: restarted \n\n\n  - name: Instalar unzip\n    apt:\n      name: unzip\n      state: present\n\n  - name: Descargar WordPress \n    ansible.builtin.get_url:\n      url: https://wordpress.org/latest.zip\n      dest: /tmp/wordpress.zip\n\n  - name: Descompresi\u00f3n de WordPress en /var/www/html\n    ansible.builtin.unarchive:\n      src: /tmp/wordpress.zip\n      dest: /var/www/html\n      remote_src: true\n\n  - name: COpiamos el archvio de configuraci\u00f3n de ejemplo y creamos uno\n    copy:\n      src: /var/www/html/wordpress/wp-config-sample.php\n      dest: /var/www/html/wordpress/wp-config.php\n      remote_src: yes\n\n  - name: configuramos las variables en el archivo de configuraci\u00f3n\n    ansible.builtin.replace:\n      path: /var/www/html/wordpress/wp-config.php\n      regexp: database_name_here\n      replace: \"{{DB_NAME}}\"\n\n  - name: configuramos las variables en el archivo de configuraci\u00f3n\n    ansible.builtin.replace:\n      path: /var/www/html/wordpress/wp-config.php\n      regexp: username_here\n      replace: \"{{DB_USER}}\"\n\n  - name: configuramos las variables en el archivo de configuraci\u00f3n\n    ansible.builtin.replace:\n      path: /var/www/html/wordpress/wp-config.php\n      regexp: password_here\n      replace: \"{{DB_PASS}}\"\n\n  - name: configuramos las variables en el archivo de configuraci\u00f3n\n    ansible.builtin.replace:\n      path: /var/www/html/wordpress/wp-config.php\n      regexp: localhost\n      replace: \"{{DB_HOST_PRIVATE_IP}}\"\n\n\n  - name: Copiamos el archivo index.php del directorio wordpress\n    copy:\n      src: /var/www/html/wordpress/index.php\n      dest: /var/www/html/index.php\n      remote_src: yes\n\n  - name: Modificaci\u00f3n del archivo wp-config.php\n    ansible.builtin.blockinfile:\n      path: /var/www/html/wordpress/wp-config.php\n      insertafter: DB_COLLATE\n      block: |\n        define('WP_HOME', '{{ WP_HOME }}');\n        define('WP_SITEURL', '{{ WP_SITEURL }}');\n\n  - name: Modificaci\u00f3n del archivo index.php para la redirecci\u00f3n a WordPress\n    ansible.builtin.replace:\n      path: /var/www/html/index.php\n      regexp: wp-blog-header.php\n      replace: wordpress/wp-blog-header.php\n\n  - name: Cambiamos  de propietario y grupo de forma recursiva al directorio /var/www/html\n    ansible.builtin.file:\n      path: /var/www/html\n      owner: www-data\n      group: www-data\n      recurse: true\n\n  - name: Reiniciamos el servidor apache\n    service:\n      name: apache2\n      state: restarted \n\n</code></pre> <p>Creamos una base de datos, un usuario y contrase\u00f1a.</p> <p>Descargamos wordpress, lo descomprimimos y lo llevamos a /var/www/html.</p> <p>Las variables de wordpress las asignaremos al archivo wp-config.php (este archivo previamente estaba dentro de la carpeta wordpress y se llamaba wp-config-sample.php, ahora lo hemos ubicado en /var/www/html)</p> <p>Adem\u00e1s de meter variables como la ip de donde se ubica la base de datos (en este caso en vez de poner la ip puse localhost, se ubica en la misma m\u00e1quina), insertamos las url que he mencionado antes.</p> <p>Modificamos el archivo index.php la linea wp-blog-header.php por wordpress/wp-blog-header.php, esto nos permitir\u00e1 la reedireci\u00f3n.</p> <p>Cambiamos los permisos y reiniciamos apache.</p>"},{"location":"9-practica/#archivos-de-configuracion","title":"Archivos de configuraci\u00f3n","text":"<p>000-default.conf</p> <p>Al a\u00f1adir la siguiente directiva al 000-default.conf , nos permiste sobrescribir las reglas de apache.</p> <pre><code>&lt;VirtualHost *:80&gt;\n        #ServerName www.example.com\n        ServerAdmin webmaster@localhost\n        DocumentRoot /var/www/html\n\n      &lt;Directory \"/var/www/html\"&gt;\n         AllowOverride All\n      &lt;/Directory&gt;  \n\n        ErrorLog ${APACHE_LOG_DIR}/error.log\n        CustomLog ${APACHE_LOG_DIR}/access.log combined\n&lt;/VirtualHost&gt;\n</code></pre> <p>dir.conf</p> <p>Modificamos el index.html y ponemos como prioridad index.php, para que la m\u00e1quina coja priorida.</p> <pre><code>&lt;IfModule mod_dir.c&gt;\n    DirectoryIndex index.php index.cgi index.pl index.html index.xhtml index.htm\n&lt;/IfModule&gt;\n</code></pre>"},{"location":"9-practica/#fase-1","title":"FASE 1","text":"<p>Para esta fase necesitaremos dos m\u00e1quina , una para el front-end y otra para el back-end.</p> <ul> <li> <p>La m\u00e1quina de front-end tendra: Servidor apache y wordpress.</p> </li> <li> <p>La m\u00e1quina de back-end tendr\u00e1 la base de datos.</p> </li> </ul> <p>El archivo de las variables no cambia, tampoco cambia la forma de obtener el certificado ni el archivo install_frontend.yml, adem\u00e1s tiene los mismos archivos de configuraci\u00f3n (000-default.conf y el dir.conf van a la m\u00e1quina front-end es lo \u00fanico nuevo), por lo tanto no lo volver\u00e9 a explicar.</p> <p>El archivo de wordpress es el mismo que la fase0, a excepci\u00f3n de mysql configuraci\u00f3n de base de datos , usuario y contrase\u00f1a, esto se debe a que la esta funcionalidad ya no est\u00e1 concentrada en una sola sino que concretamente esa labor se encargar\u00e1 el back-end.</p> <p>Instalamos mysql-server y configurar las conexiones</p> <p>Esta parte la tendremos que ejecutar al back-end, ya que es la m\u00e1quina que tendr\u00e1 la basse de datos y l m\u00e1quina del front-end se comunicar\u00e1 con el back-end para obtener la informaci\u00f3n de la base de datos.</p> <pre><code>---\n- name: Playbook para instalar la pila backend\n  hosts: bak\n  become: yes\n\n  tasks:\n  - name: Actualizar los repositorios\n    apt:\n      update_cache: yes\n\n  - name: Instalar el sistema gestor de base de datos de mysql\n    apt:\n      name: mysql-server\n      state: present\n\n  - name: Cambiamos las variables de mysql para que me accepte conexiones desde cualquier interfaz\n    ansible.builtin.replace:\n      path: /etc/mysql/mysql.conf.d/mysqld.cnf\n      regexp: 127.0.0.1\n      replace: 0.0.0.0\n\n  - name: Reiniciamos el servidor mysql\n    service:\n      name: mysql\n      state: restarted \n</code></pre> <p>Actualizamos los repositorios.</p> <p>Instalamos mysql y dentro de la ruta  /etc/mysql/mysql.conf.d/mysqld.cnf el archivo final, le cambiamos el 127.0.0.1 le pondremos 0.0.0.0 para que as\u00ed pueda conectarse con otr\u00e1s maquinas, si esto lo dejamos por defecto solo podr\u00e1 comunicarse consigo misma.</p> <p>Reiciniamos mysql.</p> <pre><code>---\n- name: Playbook para instalar la pila backend\n  hosts: bak\n  become: yes\n\n  tasks:\n\n    - name: A\u00f1adimos las variables\n      ansible.builtin.include_vars:\n        ./variables.yml\n\n    - name: Instalamos el gestor de paquetes de Python3\n      apt:\n        name: python3-pip\n        state: present\n\n    - name: Instalamos el modulo de pymysql\n      pip:\n        name: pymysql\n        state: present\n\n    - name: Crear una base de datos\n      mysql_db:\n        name: \"{{ DB_NAME }}\"\n        state: present\n        login_unix_socket: /var/run/mysqld/mysqld.sock\n\n    - name: Creamos un usuario para la Base de datos\n      no_log: true\n      mysql_user:\n        name: \"{{ DB_USER }}\"\n        host: '%'\n        password: \"{{ DB_PASS }}\"\n        priv: \"{{ DB_NAME }}.*:ALL,GRANT\"\n        state: present\n        login_unix_socket: /var/run/mysqld/mysqld.sock\n\n    - name: Reiniciamos el servidor mysql\n      service:\n        name: mysql\n        state: restarted \n</code></pre> <p>Hacemos un llamamiento a las variables para crear la base de datos, usuario y contrase\u00f1a, aunque previamente instalamos el gestor de paquetes python3-pip para instalar pymysql, esta herramienta nos permitir\u00e1 interactuar con la base de datos.</p>"},{"location":"9-practica/#fase-2","title":"FASE 2","text":"<p>Recordar</p> <p>La primera capa, pondremos un balanceador que nos permitir\u00e1 comunicar con l\u00e1s m\u00e1quinas que hay en las capas inferiores)   </p> <p>La segunda capa, tiene 3 niveles font-end (dos que servir\u00e1n como servidor apache, y un servidor nfs que contestar\u00e1 a las peticiones que les realice apache, es decir, est\u00e1 maquina tendr\u00e1 wordpress, entonces cada vez que alguien se quiera conectar al wordpress el servidor de apache preguntar\u00e1 al servidor nfs para que esa respuesta llegue finalmente al balanceador).</p> <p>La tercera capa es el back-end , la m\u00e1quina que est\u00e1 en este nivel nos dar\u00e1 la base de datos y con un usuario para wordpress.</p>"},{"location":"9-practica/#archivos-de-configuracion_1","title":"ARCHIVOS DE CONFIGURACI\u00d3N","text":"<p>Adem\u00e1s de los archivos mencionados anteriormente que son el 000-default (va en las dos m\u00e1quinas front-end).conf y el dir.conf (va en las dos m\u00e1quinas front-end).</p> <p>Aparecen el 000-default.conf del balanceador y el archivo exports (va en la m\u00e1quina nfs) que nos permitir\u00e1 montar.</p> <p>Archivo 000-default(balanceador).conf</p> <p>Le he puesto el nombre del t\u00edtulo mencionado para darle significado al archivo, cuando haga la clonaci\u00f3n modificar\u00e9 el nombre.</p> <p>En este archivo pondremos dos variables que ser\u00e1s las IPs de l\u00e1s maquinas front-end, esto se configurar\u00e1 en el archivo variables.yml.</p> <pre><code>&lt;VirtualHost *:80&gt;\n\n    &lt;Proxy balancer://mycluster&gt;\n        # Server 1\n        BalancerMember http://IP_HTTP_SERVER_1\n\n        # Server 2\n        BalancerMember http://IP_HTTP_SERVER_2\n    &lt;/Proxy&gt;\n\n    ProxyPass / balancer://mycluster/\n&lt;/VirtualHost&gt;\n</code></pre> <p>Archivo Exports</p> <p>Este archivo debe de estar en el servidor nfs.</p> <p>Si quisi\u00e9ramos compartir el directorio con todos los equipos de la subred 172.31.0.0/16 tendr\u00edamos que a\u00f1adir la siguiente l\u00ednea:</p> <pre><code>/var/www/html 172.31.0.0/16(rw,sync,no_root_squash,no_subtree_check)\n</code></pre> <p>Balanceador preparativos</p> <pre><code>---\n- name: Playbook para instalar la pila balanceador\n  hosts: balanceador\n  become: yes\n\n  tasks:\n\n  - name: A\u00f1adimos las variables\n    ansible.builtin.include_vars:\n      ./variables.yml\n\n  - name: Actualizar los repositorios\n    apt:\n      update_cache: yes\n\n  - name: Instalar el servidor web Apache\n    apt:\n      name: apache2\n      state: present\n#--------------------------------------------------------------\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: proxy\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: proxy_http\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: proxy_ajp\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: rewrite\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: deflate\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: headers\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: proxy_balancer\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: proxy_connect\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: proxy_html\n        state: present\n\n  - name: Instalamos los modulos necesarrios \n    apache2_module:\n        name: lbmethod_byrequests\n        state: present\n\n#--------------------------------------------------------\n\n  - name: Eliminamos los archivos clonados innecesarios.\n    file:\n      path: /etc/apache2/sites-available/000-default.conf\n\n\n  - name: Clonamos el repositorio\n    git:\n      repo: https://github.com/Daniel-Magana512/practica9V.git\n      dest: /tmp/archivos\n\n  - name: Movemos los archivos de configuraci\u00f3n a /etc/apache2/sites-availeble\n    copy:\n      src: /tmp/archivos/fase2/conf/000-default(balanceador).conf\n      dest: /etc/apache2/sites-available/000-default.conf\n      remote_src: yes\n\n  - name: Cambiamos el contenido del archivo 000-default.conf\n    ansible.builtin.replace:\n      path: /etc/apache2/sites-available/000-default.conf\n      regexp: IP_HTTP_SERVER_1\n      replace: \"{{IP_HTTP_SERVER_1}}\"\n\n  - name: Cambiamos el contenido del archivo 000-default.conf\n    ansible.builtin.replace:\n      path: /etc/apache2/sites-available/000-default.conf\n      regexp: IP_HTTP_SERVER_2\n      replace: \"{{IP_HTTP_SERVER_2}}\"\n\n  - name: Eliminamos los archivos clonados innecesarios.\n    file:\n      path: /tmp/archivos\n\n  - name: Reinicamos apache2\n    service: \n      name: apache2\n      state: restarted\n</code></pre> <p>Instalamos apache y los m\u00f3dulos necesarios para que est\u00e1 m\u00e1quina pueda tener ese rol de balanceador.</p> <p>Hacemos una clonaci\u00f3n de este repositorio para pasarle el archivo 000-default(balanceador).conf, despu\u00e9s lo renombraremos, lo movemos a /etc/apache/sites-available.</p> <p>Le pasamos las IPs de las dos m\u00e1quinas de front-end.</p> <p>Reiniciamos.</p> <p>Configuraci\u00f3n del servidor nfs</p> <pre><code>---\n- name: Playbook para instalar la pila nfs\n  hosts: nfs\n  become: yes\n\n  tasks:\n\n  - name: Actualizar los repositorios\n    apt:\n      update_cache: yes\n\n  - name: Instalaci\u00f3n nfs server\n    apt:\n      name: nfs-kernel-server\n\n  - name: Creamos el directorio\n    ansible.builtin.file:\n      path: /var/www/html\n      state: directory\n      mode: 0755\n      owner: nobody\n      group: nogroup\n\n  - name: Clonamos el repositorio\n    git:\n      repo: https://github.com/Daniel-Magana512/practica9V.git\n      dest: /tmp/archivos\n\n  - name: Pasamos el archivo de conf a /etc/exports\n    copy:\n      src: /tmp/archivos/fase2/conf/exports\n      dest: /etc/exports\n      remote_src: yes\n\n  - name: Eliminamos los archivos clonados innecesarios.\n    file:\n      path: /tmp/archivos\n\n  - name: Reiniciamos el servidor servidor nfs\n    service:\n      name: nfs-kernel-server\n      state: restarted \n</code></pre> <p>Instalamos el servidor nfs-kernel-server.</p> <p>Creamos el directorio /var/www/html</p> <p>Clonamos el repositorio para pasar el archivo exports a la ruta /ect/</p> <p>Eliminamos la clonaci\u00f3n previa, y reiniciamos el servidor.</p> <p>Instalaci\u00f3n de los clientes nfs</p> <pre><code>---\n- name: Playbook para instalar  wordpress\n  hosts: front\n  become: yes\n\n  tasks: \n\n  - name: A\u00f1adimos las variables\n    ansible.builtin.include_vars:\n      ./variables.yml\n\n  - name: Actualizar los repositorios\n    apt:\n      update_cache: yes\n\n  - name: Instalamos el cliente nfs\n    apt:\n      name: nfs-common\n      state: present\n\n  - name: Montamos el directorio compartido\n    ansible.posix.mount:\n      path: /var/www/html\n      src: \"{{NFS_SERVER_IP_PRIVATE}}:/var/www/html\"\n      state: mounted\n      fstype: nfs\n      opts: nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=1800\n</code></pre> <p>En este paso los clientes son los dos front-end, a los que hay que aplicarselo, para que puedan acceder al directorio que est\u00e1 compartiendo el servidor nfs.</p> <p>Instalamos el servidor cliente nfs.</p> <p>La variable NFS_SERVER_IP_PRIVATE es la ip privada de la m\u00e1quina nfs, le estamos diciendo en la \u00faltimo l\u00ednea, de la m\u00e1quina que tenga la ip de la variable su directorio /var/www/html montamelo en la direcci\u00f3n donde especif\u00edco en path. </p> <p>En el archivo de las variables</p> <p>Hay un cambio, y tenemos que poner el dominio del balanceador.</p> <pre><code>WP_HOME: https://chemaalonsooo12.ddns.net\nWP_SITEURL: https://chemaalonsooo12.ddns.net/wordpress\n</code></pre>"},{"location":"9-practica/#comprobacion","title":"Comprobaci\u00f3n","text":"<p>Aqu\u00ed podemos apreciar que puedo acceder como administrador.</p> <p></p> <p>Aqu\u00ed podemos apreciar que podemos acceder por el lado del cliente.</p> <p></p>"},{"location":"about/","title":"Bienvenido al Blog de Daniel Maga\u00f1a P\u00e9rez","text":"<p>Mi nombre es Daniel , soy estudiante de Administraci\u00f3n de Sistemas Inform\u00e1ticos en Red.</p> <p>He creado este blog con la finalidad de poder compartir mis trabajos con m\u00e1s gente al igual que espero aprender mucho sobre esta herramienta.</p> <p>Me considero una persona trabajadora, responsable y humilde. En mi tiempo libre me gusta jugar a f\u00fatbol, salir con los amigos , ver pel\u00edculas de Marvel y leer.</p> <p>Una cosa que no he mencionado antes es que adoro viajar, aprovecho cualquier excusa para salir de mi entorno para conocer nuevos lugares.</p> <p></p> <p>wordpress</p>"},{"location":"practica13_4/","title":"Actividad 13.4 Ansible-Playground","text":"<p>En esta actividad vamos a crear la arquitectura de la pr\u00e1ctica 9 y 7.</p> <p>Para generar la infraestructura, tenemos que estar dentro del directorio playbook y escribir ansible-playbook \"nombre_plantilla\".El problema de hacerlo con ansible es que tarda mucho en generar las instancias, pero no tiene mucha dificultad.</p> <p>Ahora voy a explicar el contenido de los archivos.</p>"},{"location":"practica13_4/#para-la-arquitectura-de-la-practica-7","title":"Para la arquitectura de la pr\u00e1ctica 7.","text":"<p>Voy a explicar el archivo de creaci\u00f3n de la arquitectura de la pr\u00e1ctica:</p> <pre><code>---\n- name: Este Playbook gener\u00e1 la arquitectura de la plantilla 7\n\n  #La conexi\u00f3n va a ser de forma local, solamente para crear las instancias, de manera que no voy a tener necesidad de conectarme a ellas para ejecutar comandos por eso no hay un inventario y en la conexi\u00f3n se hace de forma local. \n\n  hosts: localhost\n  connection: local\n  gather_facts: false\n\n  tasks:\n\n  #A\u00f1adimos el archivo de las variables\n\n  - name: A\u00f1adimos las variables\n    ansible.builtin.include_vars:\n      ../variables/variables.yml\n\n    #Aqu\u00ed empezamos a crear los grupos de seguridad de cada m\u00e1quina.\n\n    #Para la creaci\u00f3n de los grupos de seguridad, vamos a usar el m\u00f3dulo \"ec2_group\", una vez declarado le pasaremos el nombre del grupo , la descripci\u00f3n y los roles(aqu\u00ed hacemos la referencia a los puertos , indicamos elementos como el puerto que queremos abrir , las condiciones de la IP que debe de cumplir para interactuar con las m\u00e1quinas, el tipo de puerto, y el protocolo )\n\n  - name: Crear un grupo de seguridad del frontend\n    ec2_group:\n      name: \"{{ ec2_security_group_frontend }}\"\n      description: \"{{ ec2_security_group_description_frontend }}\"\n      rules:\n      - proto: tcp\n        from_port: \"{{ port_ssh }}\"\n        to_port: \"{{ port_ssh }}\"\n        cidr_ip: 0.0.0.0/0\n      - proto: tcp\n        from_port: \"{{ port_http }}\"\n        to_port: \"{{ port_http }}\"\n        cidr_ip: 0.0.0.0/0\n      - proto: tcp\n        from_port: \"{{ port_https }}\"\n        to_port: \"{{ port_https }}\"\n        cidr_ip: 0.0.0.0/0\n\n    #Los mismos pasos para el backend\n\n  - name: Crear un grupo de seguridad del backend\n    ec2_group:\n      name: \"{{ ec2_security_group_backend }}\"\n      description: \"{{ ec2_security_group_description_backend }}\"\n      rules:\n      - proto: tcp\n        from_port: \"{{ port_ssh }}\"\n        to_port: \"{{ port_ssh }}\"\n        cidr_ip: 0.0.0.0/0\n      - proto: tcp\n        from_port: \"{{ port_mysql }}\"\n        to_port: \"{{ port_mysql }}\"\n        cidr_ip: 0.0.0.0/0\n\n#Aqu\u00ed creamos las instancias.\n\n#Para generar las instancias vamos a usar el m\u00f3dulo \"ec2_instance\", le pasamos los siguientes parametros: el nombre de la instancia, la clave ssh, el nombre del grupo , el tipo de instancia (capacidad), y la ami. Ponemos que el estado de la m\u00e1quina sea running (que significa que est\u00e9 funcionando).\n\n#------------------------------------------------\n#Creaci\u00f3n del frontend\n#-----------------------------------------------\n\n#La \u00faltima linea \"register: ec2\" es para que tener un registro de la m\u00e1quina que luego usaremos para asociar la ip el\u00e1stica, por eso la otra instancia no se tener esta l\u00ednea.\n\n  - name: Crear instancia del frontend\n    ec2_instance:\n      name: \"{{ ec2_instance_name_frontend }}\"\n      key_name: \"{{ ec2_key_name }}\"\n      security_group: \"{{ ec2_security_group_frontend }}\"\n      instance_type: \"{{ ec2_instance_type }}\"\n      image_id: \"{{ ec2_image }}\"\n      state: running\n    register: ec2\n\n#------------------------------------------------------\n#Creaci\u00f3n backend\n#------------------------------------------------------\n  - name: Crear instancia del backend\n    ec2_instance:\n      name: \"{{ ec2_instance_name_backend }}\"\n      key_name: \"{{ ec2_key_name }}\"\n      security_group: \"{{ ec2_security_group_backend }}\"\n      instance_type: \"{{ ec2_instance_type }}\"\n      image_id: \"{{ ec2_image }}\"\n      state: running\n\n#No funciona la parte de asociar la ip el\u00e1sticas al frontend\n#-----------------------------------------------------------\n#  - name: Mostramos el contenido de la variable ec2\n#    debug:\n#      msg: \"ec2: {{ ec2 }}\"\n#\n#  - name: Crear una nueva IP el\u00e1stica y asociar a la instancia\n#    ec2_eip:\n#      device_id: \"{{ ec2.instances[0].instance_id }}\"\n#    register: eip\n\n#  - name: Mostrar la IP el\u00e1stica\n#    debug:\n#      msg: \"La IP el\u00e1stica es: {{ eip.public_ip }}\"\n</code></pre> <p>El archivo de las variables es el siguiente:</p> <pre><code>#Variables para crear el frontend, grupo de seguridad...\nec2_security_group_frontend: sg_frontend\nec2_security_group_description_frontend: Grupo de seguridad del frontend\nec2_instance_name_frontend: frontend\n\n#Variables para crear el backend, grupo de seguridad...\nec2_security_group_backend: sg_backend\nec2_security_group_description_backend: Grupo de seguridad del backend\nec2_instance_name_backend: backend\n#Variables puertos\nport_ssh: 22\nport_http: 80\nport_https: 443\nport_mysql: 3306\n\n#Variables que van a tener todas las instancias\nec2_image: ami-06878d265978313ca\nec2_instance_type: t2.small\nec2_key_name: vockey\n</code></pre> <p>Importante, para destruir la infraestructura de la pr\u00e1ctica7.</p> <pre><code>---\n- name: Playbook para eliminar un grupo de seguridad y una instancia EC2 en AWS\n\n  #La conexi\u00f3n va a ser de forma local, solamente para crear las instancias, de manera que no voy a tener necesidad de conectarme a ellas para ejecutar comandos por eso no hay un inventario y en la conexi\u00f3n se hace de forma local.\n\n  hosts: localhost\n  connection: local\n  gather_facts: false\n\n\n  tasks:\n\n  #A\u00f1adimos las variables de los recursos de la infraestructura.\n\n    - name: A\u00f1adimos las variables\n      ansible.builtin.include_vars:\n        ../variables/variables.yml\n\n#Al no asociar la ip el\u00e1stica porque no funciona , esta parte la comentar\u00e9.\n\n    # - name: Obtener el id de instancia a partir del nombre\n    #   ec2_instance_info:\n    #     filters:\n    #       \"tag:Name\": \"{{ ec2_instance_name }}\"\n    #       \"instance-state-name\": \"running\"\n    #   register: ec2\n\n #   - name: Desasociar de IP el\u00e1stica de la instancia EC2\n #     ec2_eip:\n #       device_id: \"{{ ec2.instances[0].instance_id }}\"\n #       state: absent\n\n\n#Ahora llegamos a la parte de eliminar las instancias.\n\n#Para ello usaremos el m\u00f3dulo ec2_instance, le pasamos el nombre de la instancia y de estado pondremos absent (para indicarle que queremos borrarlo.)\n\n\n    - name: Eliminar la instancia frontend\n      ec2_instance:\n        filters:\n          \"tag:Name\": \"{{ ec2_instance_name_frontend }}\"\n        state: absent\n\n    - name: Eliminar la instancia backend\n      ec2_instance:\n        filters:\n          \"tag:Name\": \"{{ ec2_instance_name_backend }}\"\n        state: absent\n\n#Ahora vamos a eliminar los grupos de seguridad, para ello usaremos el m\u00f3dulo ec2_group, le pasaremos el nombre del grupo y que tenga el estado absent.\n\n    - name: Eliminar el grupo de seguridad frontend\n      ec2_group:\n        name: \"{{ ec2_security_group_frontend }}\"\n        state: absent\n\n    - name: Eliminar el grupo de seguridad backend\n      ec2_group:\n        name: \"{{ ec2_security_group_backend }}\"\n        state: absent\n</code></pre>"},{"location":"practica13_4/#para-la-arquitectura-de-la-practica-9","title":"Para la arquitectura de la pr\u00e1ctica 9.","text":"<p>Voy a explicar la plantilla9.yml, el contenido que tiene es el siguiente:</p> <pre><code>---\n- name: Este Playbook gener\u00e1 la arquitectura de la plantilla 9\n\n  #La conexi\u00f3n va a ser de forma local, solamente para crear las instancias, de manera que no voy a tener necesidad de conectarme a ellas para ejecutar comandos por eso no hay un inventario y en la conexi\u00f3n se hace de forma local.\n\n  hosts: localhost\n  connection: local\n  gather_facts: false\n\n\n  tasks:\n\n  - name: A\u00f1adimos las variables\n    ansible.builtin.include_vars:\n      ../variables/variables.yml\n\n    #Para la creaci\u00f3n de los grupos de seguridad, vamos a usar el m\u00f3dulo \"ec2_group\", una vez declarado le pasaremos el nombre del grupo , la descripci\u00f3n y los roles(aqu\u00ed hacemos la referencia a los puertos , indicamos elementos como el puerto que queremos abrir , las condiciones de la IP que debe de cumplir para interactuar con las m\u00e1quinas, el tipo de puerto, y el protocolo )\n\n  - name: Crear un grupo de seguridad del balanceador\n    ec2_group:\n      name: \"{{ ec2_security_group_balancer }}\"\n      description: \"{{ ec2_security_group_description_balancer }}\"\n      rules:\n      - proto: tcp\n        from_port: \"{{ port_ssh }}\"\n        to_port: \"{{ port_ssh }}\"\n        cidr_ip: 0.0.0.0/0\n      - proto: tcp\n        from_port: \"{{ port_http }}\"\n        to_port: \"{{ port_http }}\"\n        cidr_ip: 0.0.0.0/0\n      - proto: tcp\n        from_port: \"{{ port_https }}\"\n        to_port: \"{{ port_https }}\"\n        cidr_ip: 0.0.0.0/0\n\n\n  - name: Crear un grupo de seguridad del frontend\n    ec2_group:\n      name: \"{{ ec2_security_group_frontend }}\"\n      description: \"{{ ec2_security_group_description_frontend }}\"\n      rules:\n      - proto: tcp\n        from_port: \"{{ port_ssh }}\"\n        to_port: \"{{ port_ssh }}\"\n        cidr_ip: 0.0.0.0/0\n      - proto: tcp\n        from_port: \"{{ port_http }}\"\n        to_port: \"{{ port_http }}\"\n        cidr_ip: 0.0.0.0/0\n\n  - name: Crear un grupo de seguridad del nfs\n    ec2_group:\n      name: \"{{ ec2_security_group_nfs }}\"\n      description: \"{{ ec2_security_group_description_nfs }}\"\n      rules:\n      - proto: tcp\n        from_port: \"{{ port_ssh }}\"\n        to_port: \"{{ port_ssh }}\"\n        cidr_ip: 0.0.0.0/0\n      - proto: tcp\n        from_port: \"{{ port_nfs }}\"\n        to_port: \"{{ port_nfs }}\"\n        cidr_ip: 0.0.0.0/0\n\n\n  - name: Crear un grupo de seguridad del backend\n    ec2_group:\n      name: \"{{ ec2_security_group_backend }}\"\n      description: \"{{ ec2_security_group_description_backend }}\"\n      rules:\n      - proto: tcp\n        from_port: \"{{ port_ssh }}\"\n        to_port: \"{{ port_ssh }}\"\n        cidr_ip: 0.0.0.0/0\n      - proto: tcp\n        from_port: \"{{ port_mysql }}\"\n        to_port: \"{{ port_mysql }}\"\n        cidr_ip: 0.0.0.0/0\n\n\n#Para generar las instancias vamos a usar el m\u00f3dulo \"ec2_instance\", le pasamos los siguientes parametros: el nombre de la instancia, la clave ssh, el nombre del grupo , el tipo de instancia (capacidad), y la ami. Ponemos que el estado de la m\u00e1quina sea running (que significa que est\u00e9 funcionando).\n\n#La \u00faltima linea \"register: ec2\" es para que tener un registro de la m\u00e1quina que luego usaremos para asociar la ip el\u00e1stica, por eso la otra instancia no se tener esta l\u00ednea.\n\n  - name: Crear instancia del balanceador\n    ec2_instance:\n      name: \"{{ ec2_instance_name_balancer }}\"\n      key_name: \"{{ ec2_key_name }}\"\n      security_group: \"{{ ec2_security_group_balancer }}\"\n      instance_type: \"{{ ec2_instance_type }}\"\n      image_id: \"{{ ec2_image }}\"\n      state: running\n    register: ec2\n\n\n  - name: Crear instancia del frontend01\n    ec2_instance:\n      name: \"{{ ec2_instance_name_frontend }}\"\n      key_name: \"{{ ec2_key_name }}\"\n      security_group: \"{{ ec2_security_group_frontend }}\"\n      instance_type: \"{{ ec2_instance_type }}\"\n      image_id: \"{{ ec2_image }}\"\n      state: running\n\n\n  - name: Crear instancia del frontend02\n    ec2_instance:\n      name: \"{{ ec2_instance_name_frontend02 }}\"\n      key_name: \"{{ ec2_key_name }}\"\n      security_group: \"{{ ec2_security_group_frontend }}\"\n      instance_type: \"{{ ec2_instance_type }}\"\n      image_id: \"{{ ec2_image }}\"\n      state: running\n\n\n  - name: Crear instancia del nfs\n    ec2_instance:\n      name: \"{{ ec2_instance_name_nfs }}\"\n      key_name: \"{{ ec2_key_name }}\"\n      security_group: \"{{ ec2_security_group_nfs }}\"\n      instance_type: \"{{ ec2_instance_type }}\"\n      image_id: \"{{ ec2_image }}\"\n      state: running\n\n\n  - name: Crear instancia del backend\n    ec2_instance:\n      name: \"{{ ec2_instance_name_backend }}\"\n      key_name: \"{{ ec2_key_name }}\"\n      security_group: \"{{ ec2_security_group_backend }}\"\n      instance_type: \"{{ ec2_instance_type }}\"\n      image_id: \"{{ ec2_image }}\"\n      state: running\n\n\n#No me deja asociar ip el\u00e1stica al balanceador\n#--------------------------------\n#  - name: Mostramos el contenido de la variable ec2\n#    debug:\n#      msg: \"ec2: {{ ec2 }}\"\n\n#  - name: Crear una nueva IP el\u00e1stica y asociar a la instancia\n#    ec2_eip:\n#      device_id: \"{{ ec2.instances[0].instance_id }}\"\n#    register: eip\n\n#  - name: Mostrar la IP el\u00e1stica\n#    debug:\n#      msg: \"La IP el\u00e1stica es: {{ eip.public_ip }}\"\n\n</code></pre> <p>El archivo de las variables es el siguiente:</p> <pre><code>#Variables para crear el balanceador, grupo de seguridad...\nec2_security_group_balancer: sg_balanceador\nec2_security_group_description_balancer: Grupo de seguridad del balanceador\nec2_instance_name_balancer: balanceador\n\n#Variables para crear el frontend, grupo de seguridad...\nec2_security_group_frontend: sg_frontend\nec2_security_group_description_frontend: Grupo de seguridad del frontend\nec2_instance_name_frontend: frontend01\nec2_instance_name_frontend02: frontend02\n\n#Variables para crear el nfs, grupo de seguridad...\nec2_security_group_nfs: sg_nfs\nec2_security_group_description_nfs: Grupo de seguridad del nfs\nec2_instance_name_nfs: nfs\n\n#Variables para crear el backend, grupo de seguridad...\nec2_security_group_backend: sg_backend\nec2_security_group_description_backend: Grupo de seguridad del backend\nec2_instance_name_backend: backend\n\n#Variables que van a tener todas las instancias\nec2_image: ami-06878d265978313ca\nec2_instance_type: t2.small\nec2_key_name: vockey\n\n#Variables de puertos\nport_ssh: 22\nport_http: 80\nport_https: 443\nport_nfs: 2049\nport_mysql: 3306\n</code></pre> <p>Para eliminar las instancias usaremos el archivo llamado \"plantilla9_eliminar.yml\" su contenido es el siguiente:</p>"},{"location":"practica13_4/#yml","title":"```yml","text":"<ul> <li>name: Playbook para eliminar un grupo de seguridad y una instancia EC2 en AWS</li> </ul> <p>#La conexi\u00f3n va a ser de forma local, solamente para crear las instancias, de manera que no voy a tener necesidad de conectarme a ellas para ejecutar comandos por eso no hay un inventario y en la conexi\u00f3n se hace de forma local.</p> <p>hosts: localhost   connection: local   gather_facts: false</p> <p>tasks:</p> <pre><code>- name: A\u00f1adimos las variables\n  ansible.builtin.include_vars:\n    ../variables/variables.yml\n</code></pre>"},{"location":"practica13_4/#este-paso-no-va-a-funcionar-porque-no-me-deja-asociar-la-ip-elastica","title":"Este paso no va a funcionar, porque no me deja asociar la ip el\u00e1stica.","text":"<pre><code># - name: Obtener el id de instancia a partir del nombre\n#   ec2_instance_info:\n#     filters:\n#       \"tag:Name\": \"{{ ec2_instance_name }}\"\n#       \"instance-state-name\": \"running\"\n#   register: ec2\n</code></pre> <p>#   - name: Desasociar de IP el\u00e1stica de la instancia EC2  #     ec2_eip:  #       device_id: \"{{ ec2.instances[0].instance_id }}\"  #       state: absent</p>"},{"location":"practica13_4/#ahora-llegamos-a-la-parte-de-eliminar-las-instancias","title":"Ahora llegamos a la parte de eliminar las instancias.","text":""},{"location":"practica13_4/#para-ello-usaremos-el-modulo-ec2_instance-le-pasamos-el-nombre-de-la-instancia-y-de-estado-pondremos-absent-para-indicarle-que-queremos-borrarlo","title":"Para ello usaremos el m\u00f3dulo ec2_instance, le pasamos el nombre de la instancia y de estado pondremos absent (para indicarle que queremos borrarlo.)","text":"<pre><code>- name: Eliminar la instancia balanceador\n  ec2_instance:\n    filters:\n      \"tag:Name\": \"{{ ec2_instance_name_balancer }}\"\n    state: absent\n\n- name: Eliminar la instancia frontend 01\n  ec2_instance:\n    filters:\n      \"tag:Name\": \"{{ ec2_instance_name_frontend }}\"\n    state: absent\n\n- name: Eliminar la instancia frontend02\n  ec2_instance:\n    filters:\n      \"tag:Name\": \"{{ ec2_instance_name_frontend02 }}\"\n    state: absent\n\n- name: Eliminar la instancia backend\n  ec2_instance:\n    filters:\n      \"tag:Name\": \"{{ ec2_instance_name_backend }}\"\n    state: absent\n\n\n- name: Eliminar la instancia nfs\n  ec2_instance:\n    filters:\n      \"tag:Name\": \"{{ ec2_instance_name_nfs }}\"\n    state: absent\n</code></pre>"},{"location":"practica13_4/#ahora-vamos-a-eliminar-los-grupos-de-seguridad-para-ello-usaremos-el-modulo-ec2_group-le-pasaremos-el-nombre-del-grupo-y-que-tenga-el-estado-absent","title":"Ahora vamos a eliminar los grupos de seguridad, para ello usaremos el m\u00f3dulo ec2_group, le pasaremos el nombre del grupo y que tenga el estado absent.","text":"<pre><code>- name: Eliminar el grupo de seguridad del balanceador\n  ec2_group:\n    name: \"{{ ec2_security_group_balancer }}\"\n    state: absent\n\n- name: Eliminar el grupo de seguridad frontend01\n  ec2_group:\n    name: \"{{ ec2_security_group_frontend }}\"\n    state: absent\n\n- name: Eliminar el grupo de seguridad frontend02\n  ec2_group:\n    name: \"{{ ec2_security_group_frontend }}\"\n    state: absent\n\n- name: Eliminar el grupo de seguridad backend\n  ec2_group:\n    name: \"{{ ec2_security_group_backend }}\"\n    state: absent\n\n- name: Eliminar el grupo de seguridad nfs\n  ec2_group:\n    name: \"{{ ec2_security_group_nfs }}\"\n    state: absent\n</code></pre>"}]}